Git is a fantastic way to work and collaborate on code projects. It ensures that none of your work is ever lost unless you put in an enormous amount of concerted effort, provides you with tools you can use to branch off and experiment, and through github allows you to easily collaborate and work with other developers.

Although it may take a bit of time to get used to as a beginner, if you can get a solid handle on how to use git, it will help vastly if you are being helped and/or having your code reviewed by a developer/mentor.

### Command Line Basics

I am well aware that there are a number of GUI apps out there that you can use to interact with git/github, but I would **strongly recommend** using the command line instead. Familiarity with command line basics is an essential as a developer anyway, and while you will grow out of GUI git clients, working with git from the command line will grow with you. If you are more interested in using a GUI to interact with git, don’t bother reading on, as the rest of this guide is heavily command-line centric.

Navigating the file system via command line is like trying to find your way around a pitch black cave network, with your only help being a small magical gremlin that will answer your questions and lead you to other rooms if you ask in the right way. At the beginning, for those who are used to navigating their cave systems with the help of a torch, this can be incredibly frustrating. In addition, the gremlin is picky about how you ask him things, so that can be annoying as well. However, as you learn and grow your relationship with the gremlin and learn more of his spells, you will find that it is actually more efficient in the end than your former torch-bearing ways.

Magical gremlins and caves out of the way, let’s jump right into it. First, go to the spotlight icon in the top right corner of your screen and type in “terminal”, then hit enter.

TODO: ![screenshot]()

This should open up a basic-looking white window with some text about your computer on it. Congratulations, you are in the first cave and can now type to your gremlin. The first thing you want to ask is where the F you are. You can find this out by asking for the **p**resent **w**orking **d**irectory, or the **pwd** for short. I’ll be showing each command in full as an example periodically throughout this section. You will also see a dollar sign before each one - this dollar sign represents our prompt, which by default probably is something like your name and a computer name. We will represent this prompt in an abstract way using the dollar sign. _Do not, I repeat, do not actually put the dollar sign into your commands!_ You command is only what is after the dollar sign.

```
$ pwd
```

It should return something like `/Users/yourname`. This is what folder you are in. Good stuff. The default is what’s called your “home folder”, because a lot of the stuff associated with your account on this computer is in it. The next thing you might want to see is what else is in the folder you’re in. You can find this out by asking for a _short list_, or **ls** of things in the folder.

```
$ ls
```

You should see a number of great things you are familiar with, like your Documents, your Desktop, etc. Good stuff. The desktop is something you know you can see visually, so let’s go there to start our work. We can change directories using the **cd** command, followed by the name of the directory you want to change to.

```
$ cd Desktop
``` 

Now, this is where the gremlin gets picky. If you typed `desktop` without a capital “D”, it would not work. This is because that’s not the name of the directory, the directory has a capital D in the name. Picky gremlin. But luckily, while picky, the gremlin is quite smart, and we can actually get him to figure out where we want to go based on the first letter or two. This is called “autocompleting”, and is done using the tab key. Try this — first run `cd` without any folder name to go back to your home directory, then type `cd Des`, then hit tab. Woah, magic - it completed the rest of the word! You could even go down to just `cd De`. But try `cd D`, and it won’t complete the first shot. Ah well, that’s because there are other folders that start with a D, so it can’t be sure. But if you hit tab again, it will actually show you the options you have filtered down to, which is pretty useful. After filling in the second letter, you’re good to go.

Now try typing `cd des` and hit tab. See what happens - no completion. Hit tab a second time — no options. This means your path was just wrong, so it’s time to try running `ls` again to see the folders and get the name right. The moral of the story here is to **always, always use tab to complete a directory name when you are changing directories**. Not only is it faster, it also makes sure that you have the name right.

One last thing to cover here. We now know how to move down through directories, but not how to move back *up*. If you are in a directory and want to go back up a level, you can use one of the two magical objects in every folder: `..` Yes, that’s two dots. Try it:

```
$ cd ..
```

Now if you type `pwd`, you’ll notice that you are back up in the parent directory of wherever you started. Sweet. So what this means is that `..` is equal to the parent directory, and it can be found in every directory (except the absolute root of the computer). Now in case you are interested, I did say earlier that there are two magical objects in every folder, and `..`, while two dots, is only one object. The second one is just `.`, and it represents the current folder. This might not seem super useful. For example, `cd`ing to `.` will just bring you to the place you already are at. But there are some other good uses for it we’ll see later. As a quick example for now, you can use the `open` command to open up a folder in the finder, like this:

```
$ open .
```

This command will open the current folder in the Finder, which actually can be quite useful. But more on the dots later on.

Let’s get back on track with git — now switch back to your desktop and let’s get started with our project. If you find yourself being confused trying to figure out which directory you are in, _re-read this section and practice moving around through different directories_. It only takes a couple commands and a small bit of practice to get a handle on figuring out how to move into a folder from the command line, but I have seen people get hung up for hours on git and have the problem end up being that they were not in the right directory. **Always be confident of where you are**, and if you aren’t, practice a little more.

### Setting Up Your Project

So by now you have figured out how to move around to folders from the command line, and this is awesome. Jump on to your desktop, right click on your actual desktop, and make a new folder — we’ll call it `example`. Now from your command line `cd` into example. If you run `ls`, you’ll see no results — the folder is empty. Makes sense. If you want to get advanced, you can run `ls -la` and it will show you the normally hidden `.` and `..` objects we were talking about before. Pretty neat. So the first step is to make some files for our project. While you can create files and folders from the command line, let’s just do it with our text editor for now.

&gt; **Pro Tip:** If you are interested in quickly creating directories and files from the command line, you can use the `mkdir` and `touch` commands, respectively. To more easily remember, think of `mkdir` as “make directory”, and `touch` as “use the [divine hand of god](http://en.wikipedia.org/wiki/File:Creaci%C3%B3n_de_Ad%C3%A1m.jpg) to create something from nothing”. You’d run these commands with one argument, the name of whatever you want to create. For example, `mkdir example` or `touch index.html`.

I’m going to use [Sublime Text](http://www.sublimetext.com/) as an example in this tutorial, but if you prefer a different text editor, feel free to try to follow with it instead. Assuming Sublime is in your dock, grab the `example` folder off your desktop and drag it onto the Sublime icon. This should pop open a window for your project. Hit `⌘ + N` to create a new file, and let’s save it as `index.html` in the `example` folder. Awesome, now you have a file in your project. To verify, run `ls` from the command line again and you should see `index.html` appear. If you want, add a simple `&lt;p&gt;hello world&lt;/p&gt;` to the file and save it. Now that we have a (simple) project, we’re ready to get started with git.

&gt; **Pro Tip:** Wouldn’t it be great if you could type a command to open the current folder you are in on the command line in sublime text? Good news — there is, you just need to set it up. Run the following command to link it: `ln -s /Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl /usr/local/bin/sub`. Now you have a command called `sub` that you can pass a folder name to open in sublime text. If you remember, `.` is the current folder, so running `sub .` would open the current folder in sublime text. Sweet!

### Git Basics

Git operates through the command line, so switch back from your editor and let’s get ready to learn some new commands. Before getting started, you’ll want to make sure you have actually [installed git](http://git-scm.org), and if you hadn’t before, pop open a new tab in your terminal once it’s done as a refresh (⌘ + T). Now, to initialize a new git project in your folder (again, make sure you are in the right folder), you can run:

```
$ git init
```

Sweet. You should see some output confirming that git has been initialized. Now first let’s look at the first and most essential git command:

```
$ git status
```

Much like you have tools such ls `ls` and `pwd` to figure out where you are in the filesystem on the command line, you have `git status` to figure out what’s going on with git. Once you have run this command, you should see that you have one untracked file, which is `index.html`, as expected.

&gt; **Pro Tip:** For a cleaner and more concise output on the `git status` command, run it with these additional options: `git status -sb`. I use git status so often that I have created a [bash alias](http://tldp.org/LDP/abs/html/aliases.html) for just the letter `s` that expands out to `git status -sb`. The way to do this depends heavily on how your computer has been configured, so this might not work if you have tinkered with the command line before, but try running these commands to add this shortcut if you want: `echo -e “\nalias s=‘git status -sb’ &gt;&gt; ~/.profile &amp;&amp; source ~/.profile”.

I’m sure you can guess the next step — make sure git _is_ tracking that file. To do this, we use the following command:

```
$ git add index.html
```

Nothing too wild here. Now if you run `git status` again, it should tell you that `index.html` is being tracked and is ready to be committed, excellent. I suppose the next question is what exactly _is_ a commit?

### Your First Commit

Now that I have built up the suspense with that headline up above there, let’s get to the answer: a commit is a snapshot of your project, with a message attached. To put this in context, let’s think about the way we traditionally save things. You might have a document in MS Word for example, and you are writing. Every once and a while, you stop writing for a minute when you feel like you have made some progress and you save, to make sure your work isn’t lost. If something goes horribly wrong, you can always not save and go back to the last saved version where you know things are good, right?

Now take that to the next level. Imagine every time you save, it’s recorded in a timeline, and at any moment you can revert back to any of your saved states. That would be a cool ability to have. Then on top of that, imagine that every time you save, it asked what you did since the last save. This way, when looking through your history, you would be able literally to see your process. In addition, it would keep track of who made the changes. So if you were having your essay edited by a friend, it would show exactly what changes your friend made _and_ that it was your friend that made them.

This is helpful for a few reasons. First, it’s easy for someone else to come in and see how your process went. Second, you can delete anything any time. No copy-pasting, no commenting-out, no alternate documents. If you don’t need it, **just get rid of it**. If you find yourself needing it again later, you can always go back and grab it since you have a clearly annotated history. And finally, it’s excellent for collaboration. You can work with other people on a project and see exactly what kind of changes they are making and where they are making them.

With the theory out of the way, let’s make our commit:

```
$ git commit -m “initial commit”
```

All this is doing is committing with a message. You must **always commit with a message**, which means you always want to use the `-m` piece. If you leave it off, it will drop you into vim to write your message, which is not where you want to be.

&gt; **Pro Tip:** If you find yourself in vim, by accident or otherwise, _do not panic_, and more importantly _do not button mash_. Vim has a very strange syntax and mode of operation especially for a beginner and if you hit _anything on the keyboard_, it will probably have an unwanted consequence. If vim comes up, type `:q!` then hit return and vim will exit. If you did panic and hit other buttons, mash the `esc` key a few times, then type `:q!` and hit enter. If that still didn’t work, close out the terminal, open a new window, `cd` back into your directory and try again — lesson learned!

Great! We made our first commit. We can verify that the commit was made using another git command to add to our toolbelt:

```
$ git log
```

This will show a log of all the commits that have been made. You should see your initial commit right there - awesome. To exit the git log, just press `q`.

&gt; **Pro Tip:** The default version of git log doesn’t look very good. But if you add a bunch of options, you can make it look great. Definitely a terminal-full, but try running this command: `git log --graph --pretty=format:'%Cred%h%Creset %an: %s - %Creset %C(yellow)%d%Creset %Cgreen(%cr)%Creset' --abbrev-commit --date=relative` - you should see a nice clean colored log. Like with `git status`, I have this aliased to `glog`, for git log. Makes it a lot quicker.

So now that we’ve made a commit, it’s just about that time to ship some code. Let’s get this project up on [github](https://github.com)!

### Shipping Code

So let’s talk about repositories. A **repository** is the term for a project that’s using git. So while it may sound fancy, it just means a folder with files in it that use git as version control. So you have a repository on your computer now which you just pushed one commit to — we’ll refer to this as your **local** repository, because it’s on your computer only. Github offers you the chance to make a **remote** copy of your repository so that other people can check it out and collaborate. But don’t forget that your local repository and the version you push to github are still different — you need to keep them in sync.

First, let’s create an empty repository on github so we can sync it with our local one. Hit up http://github.com and make an account. Now, in the top right corner, hit the “+” button and select “new repository”. Give it a name (like example) and hit create without selecting any additional options. Github now gives you some instructions on how to get started. Let’s actually take a look at these instructions and break them down.

```
touch README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/jenius/example.git
git push -u origin master
```

These actually are all commands that we are familiar with, save for the last two. As we learned in a pro tip above, `touch` creates a new file, we know `git init` initializes git for a directory, we know `git add` adds the file to be tracked, we already made our commit. Now you’ll notice that it also has instructions for pushing an existing repository, which really is our situation:

```
git remote add origin https://github.com/jenius/example.git
git push -u origin master
```

…and you’ll see here that this is just the last two commands from the instruction set above. So let’s go over what exactly these are doing. Starting with this first command, base `git remote` it is followed by three arguments: `add`, `origin`, and a url. In order, this is telling git what to do remotely (you can add a new remote repository, remove one, list them, etc), the second argument is the name of the remote repository, and the third is where exactly to find it.

You might think that “origin” is something of a special word here, but it is actually just a normal name — you could name your remote link to github anything you want. Using the word “origin” to refer to the primary remote repository is simply a convention when using git. If you’d like to test using another name (like github), feel free, but I would recommend sticking with “origin” just to get used to the convention.

Now on to the second command. `git push` is pretty clear — we want to push our code somewhere. Ignore the `-u` for now, you can omit it if you want, not important. The second piece, `origin master`, is important though. You’ll recognize `origin` as the name of your remote github repo, so you could probably figure out that this first command tells git _where_ to push the code. But what’s `master`?

This delves into the concept of branches, which we will discuss later. As a quick summary, a branch is a separate copy of your project that you can mess with and it doesn’t interfere with any other branch. For example, if you wanted to add some experimental javascript, you could create a new branch to put your javascript on. If it was looking good, you could merge that branch back into your main branch. If not, you could get rid of it. If that’s not super clear, _don’t worry_ — we’ll go over branches in detail later. What’s important is that you understand that you can have multiple copies of your project to test things out in. `master` is the **main copy of the project**. It’s actually the name of a branch — the default branch. You already are on that branch, and don’t have to worry about it. So by specifying `origin` and `master` to the `git push` command you are telling git **where to push** and **what code to push**, respectively.

Ok, so let’s run those two commands. After completing, head back to github in your browser and refresh that page — you should see that your repo has now been populated with your `index.html` file — whoo! If you click the file, you’ll see the contents just as you wrote them. This code is now public, and anyone can access it and work with you on it. And we will be discussing working with other people in depth a little later.

&gt; **Pro Tip**: If you are still wondering about the `-u` option, what it does is set the default upstream, which essentially means that in the future if you just run `git push` without specifying where or what to push, it will assume `origin master`. If you don’t use the `-u`, a default upstream will not be set, and if you run `git push` it will give you an error, asking for more details. More on upstreams later though.

### Pushing More Code

So we just made our first commit to git and also released our first open source code. This is awesome! Why stop here — let’s keep pushing code. We can continue with the same cycle to make and push another commit. Let’s break down the process:

- Make some changes to your project
- Run `git status` to see what changes you made
- Use `git add .` to stage your changes for commit
- Run `git status` again to make sure the changes were staged
- Use `git commit -m “a message”` to make a commit
- Run `git status` to confirm that the commit has been made
- Push our code to github using `git push origin master`

Now, you may think that the git status stuff is overboard, but **it is important to get into the habit of using git status frequently when working with git**. This is because, as is the case with most things on the command line, the interface does not present the state of thing to you, you must ask it for state. You can compare this directly to moving between folders as discussed earlier, where you can’t _see_ where you are, but you can ask the gremlin with `ls` or `pwd`. When dealing with git, it’s the same way — you just ask git what the deal is. If you followed the pro tip above and aliased `git status` to simply `s`, this makes checking your status very quick and easy, and is a great way to make sure that nothing went wrong.

So take some time now to make some changes to your project, commit, and push them. Then do it again. Practice this for a bit. Start to build up a little website, and get into the rhythm. Whenever you have finished a significant feature, stop and make a commit, then push it. But don’t forget to keep reading too, because there’s plenty more to learn!

### Commit Style

There are plenty of opinions out there on how to write and structure your commits, and you can and should read about them, try them out, and see if they make sense to you. What I will recommend here is the result of a lot of research and a lot of time working with git, both on personal projects and with other developers, and I’m definitely opinionated and think it’s the best way to do it. But keep in mind that if you are working with people who prefer a different style, you can and should try to find a middle ground.

First, the **tense** of your commit messages. I would recommend using present imperative tense. For a couple examples:

- “fix bug in css”
- “refactor about page javascript”
- “add legal terms”

Why? The [documentation for git itself](http://stackoverflow.com/questions/3580013/should-i-use-past-or-present-tense-in-git-commit-messages) states that present imperative tense is preferred, and when git and/or github auto-generates commit messages, they will be in present imperative tense. In addition, this tense carries as little weight as possible — it is entirely neutral. It doesn’t say that something happened in the past, will happen in the future, or is currently happening. It simply states that it happens. How to interpret this is up to the reader.

You might see other people use other tenses such as “fixes bug in css” or “fixed bug in css”. If you are working on a project someone else is leading and they are consistent with the tense they use, be respectful and stick with their tense. Otherwise, I would get used to present imperative.

Second, the **breakdown of the commit**. A commit message actually has two parts: a summary and details. What you are writing in the `-m “…”` section is just the summary - a short overview, no more than 50 characters, of what the commit does. Any further details should go in the details section. To add to the details section, you’ll either need to use vim or a GUI such as gitx to write the commit. Vim is the recommended way to do it, see the pro tip below for more details if you are interested. If not, just remember to make your commit summaries concise high level summaries of what you have done. If you find yourself writing a novel, perhaps you should be splitting into multiple commits rather than one.

&gt; **Pro Tip:** Using vim can be a good way to write commit messages once you are used to it. To use vim for a commit message, just run `git commit` without the `-m`. Vim has a very strange way of working. By default, you are in what’s called “command mode”, which is for editing, not inserting text. The first thing you’ll want to do is hit the `i` key to enter insert mode. From here, it works more or less as a normal text editor. Your summary goes on the first line, and if you want to add commit details, just return and put them on the next line. When finished, hit `esc`, then type `:wq` and hit enter. These commands return you to command mode, then save and quit out of vim. If you hit some wrong keys and things have gone downhill, as noted in an earlier pro tip, just mash escape then hit `:q!` and enter and you should be out of trouble. You may need to redo the commit, but it’s better than restarting your terminal!

Finally, let’s go over **the purpose of `git add`**. You might think that it seems silly for you to need to run `git add` every time instead of just `git commit` handling all your files, but `git add` actually has a specific and very useful purpose — rather than running `git add .` every time, you can pick out specific files you want to stage for a commit, which allows you to break down your changes into multiple commits. For example, if you refactored your css and also changed around a bit of html, you might want to split those into different commits for clarity. To do this, you could just run `git add style.css`, followed by a commit, then add the rest using `git add index.html` or just `git add .` and finish it out with a second commit.

### Branches

We’ve heard about branches before, and we know that the default branch is called **master**, which if you recall is also what you push to github. But let’s take some time here to go over what exactly a branch is, and how to use branches effectively when using git.

Now that you are cranking out commits with style and grace, let’s move on to how to work with other developers using git.

### Collaboration

There’s no reason to use github if you aren’t collaborating with other people on your code! Github knows this, and they have built a top-of-the-line toolkit for collaborating with code into their platform.

An important thing to remember about git is that you are often working with _multiple repositories_ that you want to keep in sync. For example, when you created and pushed your code to github, you were synchronizing the github repository with your local one — although they often hold the same code, they are two different repositories, stored in two different places. If you make another commit, it’s _not going to show up on github by default_, and if someone else pushed code to the github repository, it won’t show up on your computer. You are in control of how and when you keep things in sync.

So let’s say that you have a friend contributing to your project. Nobody is allowed to make changes to your code unless you specifically allow it (can you imagine if anyone could change any of your code by default?). There are two ways for other people to contribute to your code on github. First, they could **fork** your project making a copy of it under their own name, make changes, push to their own version then make a **pull request**, asking you to pull their changes into your project. We’ll talk more about forking and pull requests later. The second way is to give someone access to push code to your repository. Let’s assume this is a trusted friend and you’d like to give them access to make changes to your code, because you are working together, and move ahead with this for now.

&gt; **Pro Tip**: If you are doing this in real life, you can go to “Settings” &gt; “Collaborators” in your repo, and add your friend by typing in their github username.

Now let’s say you’ve made your commit and your friend is now making some changes to the project and pushes them. At the same time, you made some changes, and you try to push your changes after your friend’s. This is what could end up as an ugly situation — you don’t want anyone’s code to be overwritten. For situations like this, git has to **merge** the two sets of changes together. Now, it could be an easy merge, if, for example you added a line to `index.html` and your friend added a new file called `style.css`. The changes don’t conflict, and can be merged together seamlessly. On the other hand, if your friend had added a new line to `index.html` that’s different from your line, this could be a little more ugly. Git can’t figure out which one to use (or whether to use both) — that’s something that only you can make the call on. This latter situation is what’s referred to as a **merge conflict**, and we’ll go into more detail about these later.

What’s important to know here is that in order to progress, you need to **pull** your friend’s changes down from github into your local repository and allow git to merge them, bringing you up to sync, before you can push your new changes. If you try to push to a repo that someone else has modified, git will give you an error message telling you that you need to pull first. This is ok — if you see this, do not panic, just follow the instructions (pull first before pushing). We saw how to push the master branch to origin (github) using `git push origin master`, can you guess how to pull?

```
$ git pull origin master
```

…that was a tough one, I know. Pull the master branch down from the origin. Sweet. When you do this, git will find any new commits and try to merge them with yours. As long as you didn’t change the exact same line of code to something different than someone else changed it to, the merge will happen automatically, and you’ll be able to push your changes seamlessly. If that did happen, as mentioned above, we have a merge conflict on our hands.

### Merge Conflicts

Unfortunate as they are, merge conflicts do happen. And when they do, they throw down a very ugly error message, and put your project in somewhat of a purgatory state until you have resolved it. But really, resolving these conflicts is not so bad, so let’s walk through it.

First thing I usually do when a merge conflict comes up is clear out the gigantic ugly merge conflict message. It’s very frightening, really. There are cleaner ways we can look at this. I clear my console compulsively with `⌘ + K` — you can also type `clear` and hit enter to clear things out. Or if you just want to keep the message there, that’s also cool. Next thing, run `git status` to see what the story is. You’ll probably see something like this:

```
TODO: fill this in with a sample merge conflict
```

So the files with `TODO` next to them are files that there is a conflict in. In your text editor, jump into a conflicted file, and let’s check it out. In the example I’m giving here,  there was a change made in the `index.html` file to the same line. Looking in that file, we see something like this:

```
TODO: fill this in with sample conflict file contents
```

As you can see, git has injected some markup where the conflict is. It has it split into two sections, the first one marked as `HEAD` and the second one marked with a seemingly random number.
